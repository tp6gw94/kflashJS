<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Document</title>
</head>
<body>
<button id="connect">更新韌體</button>
<p id="progress">Waiting...</p>
</body>
<script src="lib/pako_inflate.min.js"></script>
<script src="lib/crc.js"></script>
<script type="module">
  import kflash, { FlashModeResponse, delay } from "./kflash.js";
  import struct from "./lib/struct.mjs";
  import ISP_PROG from "./lib/isp.js";

  const ISP_FLASH_SECTOR_SIZE = 4096;
  const ISP_FLASH_DATA_FRAME_SIZE = ISP_FLASH_SECTOR_SIZE * 16;
  const progressElem = document.getElementById('progress');

  navigator.serial.addEventListener('connect', (e) => {
    console.log('connect port', e);
  });

  navigator.serial.addEventListener('disconnect', e => {
    console.log('disconnect ', e);
  });

  document.getElementById('connect').addEventListener('click', async () => {
    await navigator.wakeLock.request('screen');
    await kflash.requestSerialPort();

    fetch('firmware/webai.bin').then(resp => {
      return resp.blob();
    }).then(data => {
      return data.arrayBuffer();
    }).then(data => {
      return Array.from(new Uint8Array(data));
    }).then(firmware => {
      let address = 0x000000;
      const addressBinMap = {};

      while (firmware.length) {
        const chunk = firmware.splice(0, ISP_FLASH_DATA_FRAME_SIZE);
        while (chunk.length < ISP_FLASH_DATA_FRAME_SIZE) {
          chunk.push(0);
        }

        const op_p = new Uint8Array(
          struct("<HH").pack(
            FlashModeResponse.Operation.ISP_FLASH_WRITE,
            0x00
          )
        );

        const address_p = new Uint8Array(
          struct("<II").pack(address, chunk.length)
        );

        const crc32_checksum = new Uint8Array(
          struct("<I").pack(
            crc.crc32([...address_p, ...chunk]) & 0xffffffff
          )
        );

        const packet = [...op_p, ...crc32_checksum, ...address_p, ...chunk];

        addressBinMap[address] = packet;
        address += ISP_FLASH_DATA_FRAME_SIZE;
      }

      return addressBinMap;
    }).then(async (addressBinMap) => {
      console.time('firmware');
      console.log(addressBinMap);
      progressElem.innerText = 'init...';
      const loader = await kflash.init_write();

      const boot = async () => {
        console.log('change_baudrate 115200')
        await loader.change_baudrate(115200);
        // 1. Greeting
        console.log("Trying to Enter the ISP Mode...");
        let retry_count = 0;
        while (true) {
          try {
            retry_count += 1;
            if (retry_count > 15) {
              console.log(
                "[ERROR]",
                "No vaild Kendryte K210 found in Auto Detect, Check Your Connection or Specify One by"
              );
            }
            try {
              console.log(".");
              await loader.reset_to_isp();
              await loader.greeting();
              break;
            }
            catch (e) {
              console.log(e)
              console.log("timeouterror");
            }
          }
          catch {
            console.log("Greeting fail, check serial port");
          }
        }

        // 2. download bootloader and firmware
        console.log("download bootloader and firmware");
        const resp = await loader.install_flash_bootloader();
        if (resp === 'timeout') return 'timeout';

        // Boot the code from SRAM
        await loader.boot();

        console.log("Wait For 0.1 second for ISP to Boot");
        await delay(0.1);

        console.log("flash_greeting");
        await loader.flash_greeting();

        console.log("change_baudrate 2000000");

        await loader.change_baudrate(2000000);
        await delay(0.01)

        console.log("flash_greeting");
        await loader.flash_greeting();
        console.log("init_flash");
        await loader.init_flash();
      }

      let bootResp = await boot();

      while (bootResp === 'timeout') {
        // await loader.reset_to_boot();
        bootResp = await boot();
      }

      let progress = 0;

      for (let address in addressBinMap) {
        const addressList = Object.keys(addressBinMap);
        const idx = addressList.findIndex(_address => _address === address);
        progress = (idx / addressList.length * 100).toFixed(2);

        progressElem.innerText = progress + '%';

        let resp = await loader.flash_firmware(addressBinMap[address]);
        console.log(new Date(), address, resp);
        while (!resp) {
          await new Promise((resolve) => setTimeout(resolve, 1000 * 1));
          await loader.reset_to_boot();
          console.log("Rebooting...");
          await new Promise((resolve) => setTimeout(resolve, 1000 * 5));
          bootResp = await boot();
          while (bootResp === 'timeout') {
            await loader.reset_to_boot();
            bootResp = await boot();
          }
          // const init_resp = await Promise.race([kflash.init_write, new Promise(resolve => setTimeout(
          //   () => resolve(false),
          //   60 * 1000))]);
          // if (!init_resp) continue;
          resp = await loader.flash_firmware(addressBinMap[address]);
        }
      }
      return loader;
    }).then(async (loader) => {
      await kflash.reboot();
      progressElem.innerText = '100%'
      console.timeEnd('firmware');
    });
  });


  // get firmware
  // let firmware = null;
  // fetch("firmware/webai.bin")
  //   .then((response) => {
  //     return response.blob();
  //   })
  //   .then((data) => {
  //     firmware = data;
  //     console.log(firmware);
  //   });

  // const printProgressBarListener = (percent) => {
  //   console.log(`進度 ${percent}`);
  // };
  //
  // console.log(board_boot)
  //
  // connect.onclick = async () => {
  //   await kflash.requestSerialPort();
  //   window.dispatchEvent(write_firmware);
  // };
  //
  // window.addEventListener('write_firmware',async () => {
  //   console.log('write_firmware');
  //   const result = await kflash.write(0x000000, firmware, printProgressBarListener);
  //   if (!result) window.dispatchEvent(write_firmware);
  // });
</script>
</html>
